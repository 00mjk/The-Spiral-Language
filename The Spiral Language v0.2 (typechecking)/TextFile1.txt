let server_tokenizer (uri : string) = Job.delay <| fun () ->
    let lines : LineToken [] ResizeArray = ResizeArray([[||]])
    let mutable errors_tokenization = [||]
    let mutable blocks : Block list = []

    let replace edit =
        errors_tokenization <- Tokenize.replace lines errors_tokenization edit // Mutates the lines array
        blocks <- block_separate lines blocks edit
        blocks, errors_tokenization

    let req = Ch()
    let loop =
        Ch.take req >>= function
            | Put(text,res) -> replace {|from=0; nearTo=lines.Count; lines=Utils.lines text|} |> IVar.fill res
            | Modify(edits,res) -> replace edits |> IVar.fill res
            | GetRange((a,b),res) -> // It is assumed that a.character = 0 and b.character = length of the line
                let from, near_to = min (lines.Count-1) a.line, min lines.Count (b.line+1)
                vscode_tokens from (lines.GetRange(from,near_to-from |> max 0).ToArray()) |> IVar.fill res
    
    Job.foreverServer loop >>-. req

type ParserReq = {
    blocks : Block list
    res : ParserResult IVar
    }

let server_parser (uri : string) = Job.delay <| fun () ->
    let is_top_down = System.IO.Path.GetExtension(uri) = ".spi"
    let dict = System.Collections.Generic.Dictionary(HashIdentity.Reference)
    let parse (a : Block list) =
        let b = 
            List.map (fun x -> {
                parsed = Utils.memoize dict (block_init is_top_down) x.block
                offset = x.offset
                }) a
        dict.Clear(); List.iter2 (fun a b -> dict.Add(a.block,b.parsed)) a b
        block_bundle b

    let req = Ch()
    let rec waiting () = Ch.take req ^=> processing
    and processing (a : ParserReq) = waiting () <|> Alt.prepareJob (fun () -> IVar.fill a.res (parse a.blocks) >>- waiting)
        
    Job.server (waiting()) >>-. req

open Spiral.Infer
type TypecheckingReq = {
    bundles : Bundle list
    res : InferResult IVar list IVar
    }

let server_typechecking (uri : string) = Job.delay <| fun () ->
    let req = Ch ()

    let rec waiting data = req ^=> extracting data
    and extracting data req' = 
        waiting data <|> (IVar.read req' ^=> fun (req' : TypecheckingReq) -> 
            let rec loop = function // Does memoization by fetching previous computed values.
                | [], bundle -> List.map (fun _ -> IVar()) bundle
                | (a, ivar) :: a', (b :: b' as bundle) -> if a = b then ivar :: loop (a',b') else loop ([], bundle)
                | _, [] -> []
            let x = loop (data, req'.bundles)
            Hopac.start (IVar.fill req'.res x)
            let x = List.zip req'.bundles x
            processing Infer.default_env x x
            )
    and processing state data = function
        | [] -> waiting data
        | (x,res) :: x' ->
            waiting data <|> Alt.prepareFun (fun () -> 
                if res.Full then IVar.read res ^=> fun x -> processing x.top_env data x'
                else 
                    let x = bundle x |> infer state
                    Hopac.start (IVar.fill res x)
                    processing x.top_env data x'
                )

    Job.server (waiting []) >>-. req

let server_hover (uri : string) = Job.delay <| fun () ->
    let req_tc, req_hov = Ch (), Ch ()

    let block_at data (pos : Config.VSCPos) = 
        let rec loop = function // tryPick from the back
            | (offset,b) :: x' ->
                match loop x' with
                | ValueSome _ as x -> x
                | ValueNone -> if offset <= pos.line then ValueSome b else ValueNone
            | [] -> ValueNone
        loop data |> function ValueSome x -> x | ValueNone -> IVar()

    let hover_msg_at (pos : Config.VSCPos) ranges =
        ranges |> Array.tryPick (fun ((a,b) : Config.VSCRange, r : string) ->
            if pos.line = a.line && (a.character <= pos.character && pos.character < b.character) then Some r else None
            )

    let signal_none ret x = Option.iter ((|>) None) ret; x
    let rec tc ret = req_tc ^=> (signal_none ret >> extracting)
    and hov data ret = req_hov ^=> (signal_none ret >> processing data)
    and waiting data ret = tc ret <|> hov data ret
    and extracting req = tc None <|> (IVar.read req ^=> extracting')
    and extracting' (req : TypecheckingReq) =
        tc None 
        <|> (IVar.read req.res ^=> fun x -> waiting (List.map2 (fun (a : Bundle) b -> (List.head a).offset, b) req.bundles x) None)
    and processing data (pos, ret) =
        waiting data (Some ret)
        <|> (IVar.read (block_at data pos) ^=> fun x -> hover_msg_at pos x.hovers |> ret; waiting data None)

    Job.server (tc None) >>-. (req_tc, req_hov)
