inl (+) forall t {number}. (a : t) (b : t) : t = !!!!Add(a,b)
inl (-) forall t {number}. (a : t) (b : t) : t = !!!!Sub(a,b)
inl (*) forall t {number}. (a : t) (b : t) : t = !!!!Mult(a,b)
inl (**) forall t {number}. (a : t) (b : t) : t = !!!!Pow(a,b)
inl (/) forall t {number}. (a : t) (b : t) : t = !!!!Div(a,b)
inl (%) forall t {number}. (a : t) (b : t) : t = !!!!Mod(a,b)

inl (<=) forall t {number}. (a : t) (b : t) : bool = !!!!LTE(a,b)
inl (<) forall t {number}. (a : t) (b : t) : bool = !!!!LT(a,b)
inl (=) forall t {number}. (a : t) (b : t) : bool = !!!!EQ(a,b)
inl (<>) forall t {number}. (a : t) (b : t) : bool = !!!!NEQ(a,b)
inl (>) forall t {number}. (a : t) (b : t) : bool = !!!!GT(a,b)
inl (>=) forall t {number}. (a : t) (b : t) : bool = !!!!GTE(a,b)

inl (=) forall t. (a : t) (b : t) : bool = !!!!EQ(a,b)
inl (<>) forall t. (a : t) (b : t) : bool = !!!!NEQ(a,b)

inl (|>) a b = b a
inl (>>) a b x = b (a x)
inl dyn (~x) = x

inl array_create forall t. (size : i32) : array t = !!!!ArrayCreate(`t,size)
inl array_index forall t. (ar : array t) (i : i32) : t = !!!!ArrayIndex(ar,i)
inl array_set forall t. (ar : array t) (i : i32) (v : t) : () = !!!!ArrayIndexSet(ar,i,v)
inl array_length forall t. (ar : array t) : i32 = !!!!ArrayLength(ar)

inl for (from: nearTo:) body state =
    let rec loop i s = if i < nearTo then loop (i+1) (body i s) else s
    loop from state

inl for' (from: nearTo:) body = for (from:nearTo:) (fun i () => body i) ()

inl array_fold f s ar = for (from: 0 nearTo: array_length ar) (fun i s => f s (array_index ar i)) s
inl array_map f ar =
    inl nearTo = array_length ar
    inl ar' = array_create nearTo
    for' (from: 0 nearTo: ) (fun i => array_set ar' i (f (array_index ar i)))
    ar'

inl array_filter f ar =
    inl nearTo = array_length ar
    inl ar' = array_create nearTo
    inl nearTo =
        for (from:0 nearTo:) (fun i count =>
            if f i then array_set ar' i (array_index ar i) . count + 1
            else count
            ) 0
    inl ar = ar'
    inl ar' = array_create nearTo
    for' (from:0 nearTo:) (fun i => array_set ar' i (array_index ar i))
    ar'

inl writeline (x : string): () = $"System.Console.WriteLine(!x)"
inl readline (): string = $"System.Console.ReadLine()"

inl string_index (str : string) (i : i32): char = !!!!StringIndex(str,i)
inl string_length (str : string): i32 = !!!!StringLength(str)

union list a = Nil | Cons: a, list a
union result a b = Ok: a | Error: b

inl list_singleton x = Cons: x, Nil

type env = i32
type cont a b r = {on_succ : a -> r; on_fail : b -> r} -> r
nominal parser a = string -> env -> result a (list string), env
nominal cps_parser a r = string -> env -> cont (a, env) (list string, env) (r, env)
inl run_cps (cps_parser a) str i on = a str i on
inl run (parser x) str i = x str i
inl conv (cps_parser a) = parser fun str i => a str i { on_succ=fun ok,i => (Ok:),i; on_fail=fun error,i => (Error:),i}

inl Char' = cps_parser fun str i {on_succ on_fail} =>
    if i < string_length str then on_succ (string_index str i, i+1)
    else on_fail (list_singleton "Out of bounds.", i)

inl Char = conv Char'

inl i32 (x : char): i32 = !!!!UnsafeConvert(`i32,x)
inl is_digit x = i32 '0' <= i32 x && i32 x <= i32 '9'
inl Digit = parser fun str i =>
    match run Char str i with
    | (Ok: a), i' as x => if is_digit a then x else (Error: list_singleton "digit"), i'
    | er => er

inl I32 = parser fun str i =>
    let rec loop i was_parsed s =
        match run Digit str i with
        | (Ok: c), i => 
            inl s' = s * 10 + i32 c
            if s <= 214_748_364 && 0 <= s' then loop i true s'
            else (Error: list_singleton "The number is too large to be parsed as 32 bit int."), i
        | (Error: _), i => if was_parsed then (Ok: s), i else (Error: list_singleton "i32"), i
    loop i false 0

inl on_succ ok = parser fun _ i => (Ok:), i
inl (>>=) (parser a) f = parser fun str i => 
    match a str i with
    | (Ok: a), i => run (f a) str i
    | (Error: l), i => (Error: l), i

inl (<<;) a b =
    a >>= fun a =>
    b >>= fun b =>
    on_succ (a,b)

inl (<<.) a b =
    a >>= fun a =>
    b >>= fun b =>
    on_succ b

inl (<<,) a b =
    a >>= fun a =>
    b >>= fun b =>
    on_succ a

inl Parse3Ints = I32 <<; I32 <<; I32