inl (+) forall t {number}. (a : t) (b : t) : t = !!!!Add(a,b)
inl (-) forall t {number}. (a : t) (b : t) : t = !!!!Sub(a,b)
inl (*) forall t {number}. (a : t) (b : t) : t = !!!!Mult(a,b)
inl (**) forall t {number}. (a : t) (b : t) : t = !!!!Pow(a,b)
inl (/) forall t {number}. (a : t) (b : t) : t = !!!!Div(a,b)
inl (%) forall t {number}. (a : t) (b : t) : t = !!!!Mod(a,b)

inl (<=) forall t {number}. (a : t) (b : t) : bool = !!!!LTE(a,b)
inl (<) forall t {number}. (a : t) (b : t) : bool = !!!!LT(a,b)
inl (=) forall t {number}. (a : t) (b : t) : bool = !!!!EQ(a,b)
inl (<>) forall t {number}. (a : t) (b : t) : bool = !!!!NEQ(a,b)
inl (>) forall t {number}. (a : t) (b : t) : bool = !!!!GT(a,b)
inl (>=) forall t {number}. (a : t) (b : t) : bool = !!!!GTE(a,b)

inl (=) forall t. (a : t) (b : t) : bool = !!!!EQ(a,b)
inl (<>) forall t. (a : t) (b : t) : bool = !!!!NEQ(a,b)

inl (|>) a b = b a
inl (>>) a b x = b (a x)
inl (<|) a b = a b
inl (<<) a b x = a (b x)
inl dyn (~x) = x

inl array_create forall t. (size : i32) : array t = !!!!ArrayCreate(`t,size)
inl array_index forall t. (ar : array t) (i : i32) : t = !!!!ArrayIndex(ar,i)
inl array_set forall t. (ar : array t) (i : i32) (v : t) : () = !!!!ArrayIndexSet(ar,i,v)
inl array_length forall t. (ar : array t) : i32 = !!!!ArrayLength(ar)

inl for (from: nearTo:) body state =
    let rec loop i s = if i < nearTo then loop (i+1) (body i s) else s
    loop from state

inl for' (from: nearTo:) body = for (from:nearTo:) (fun i () => body i) ()

inl array_init nearTo f = 
    inl ar = array_create nearTo
    for' (from: 0 nearTo:) (fun i => array_set ar i (f i))
    ar

inl array_fold f s ar = for (from: 0 nearTo: array_length ar) (fun i s => f s (array_index ar i)) s
inl array_map f ar = array_init (array_length ar) (fun i => f (array_index ar i))
inl array_filter f ar =
    inl nearTo = array_length ar
    inl ar' = array_create nearTo
    for (from:0 nearTo:) (fun i count => if f i then array_set ar' i (array_index ar i) . count + 1 else count) 0
    |> fun nearTo => array_init nearTo (array_index ar')

inl writeline (x : string): () = $"System.Console.WriteLine(!x)"
inl readline (): string = $"System.Console.ReadLine()"

inl string_index (str : string) (i : i32): char = !!!!StringIndex(str,i)
inl string_length (str : string): i32 = !!!!StringLength(str)

union list a = Nil | Cons: a, list a
union result a b = Ok: a | Error: b
union option a = Some: a | None

inl list_singleton x = Cons: x, Nil

type env = i32
type cont a b r = {on_succ : a -> r; on_fail : b -> r} -> r
nominal parser a = string -> env -> result a (list string), env
nominal cps_parser a r = string -> env -> cont (a, env) (list string, env) (r, env)
inl run_cps (cps_parser a) str i on = a str i on
inl run (parser x) str i = x str i
inl conv (cps_parser a) = parser fun str i => a str i { on_succ=fun ok,i => (Ok:),i; on_fail=fun error,i => (Error:),i}

inl Char' = cps_parser fun str i {on_succ on_fail} =>
    if i < string_length str then on_succ (string_index str i, i+1)
    else on_fail (list_singleton "Out of bounds.", i)

inl Char = conv Char'

inl i32 (x : char): i32 = !!!!UnsafeConvert(`i32,x)
inl is_digit x = i32 '0' <= i32 x && i32 x <= i32 '9'
inl Digit = parser fun str i =>
    match run Char str i with
    | (Ok: a), i' as x => if is_digit a then x else (Error: list_singleton "digit"), i'
    | er => er

inl I32 = parser fun str i =>
    let rec loop i was_parsed s =
        match run Digit str i with
        | (Ok: c), i => 
            inl s' = s * 10 + i32 c
            if s <= 214_748_364 && 0 <= s' then loop i true s'
            else (Error: list_singleton "The number is too large to be parsed as 32 bit int."), i
        | (Error: _), i => if was_parsed then (Ok: s), i else (Error: list_singleton "i32"), i
    loop i false 0

inl on_succ ok = parser fun _ i => (Ok:), i
inl (>>=) (parser a) f = parser fun str i => 
    match a str i with
    | (Ok: a), i => run (f a) str i
    | (Error: l), i => (Error: l), i

inl (<<;) a b =
    a >>= fun a =>
    b >>= fun b =>
    on_succ (a,b)

inl (<<.) a b =
    a >>= fun a =>
    b >>= fun b =>
    on_succ b

inl (<<,) a b =
    a >>= fun a =>
    b >>= fun b =>
    on_succ a

inl Parse3Ints = I32 <<; I32 <<; I32

prototype eq x : x -> x -> bool
instance eq list el {eq} = fun a b =>
    let rec loop = function
        | Nil, Nil => true
        | (Cons: a,a'), (Cons: b,b') when eq a b => loop (a',b')
        | _ => false
    loop (a,b)

let rec poly forall t. (x : t): t =
    inl q = poly true
    inl w = poly "qwe"
    inl e = poly' 1i32
    x
and let poly' forall t {number}. (x : t): t = poly x

inl failwith (x : string) = $"failwith !x"
inl const x _ = x

union player = First | Second

inl game_of_stones n =
    inl max_n = 100
    if max_n < n then failwith "The max input has been exceeded."
    inl solutions = array_init (max_n+1) (const None)
    let rec solve player opposing_player n =
        inl take amount on_fail () = 
            if n >= amount && solve opposing_player player (n-amount) = player then player
            else on_fail ()

        let run = take 2 <| take 3 <| take 5 <| const opposing_player

        match player with
        | First => 
            match array_index solutions n with
            | None => inl x = run() in array_set solutions n (Some: x) . x
            | Some: x => x
        | Second => run()
    solve First Second n