let test102: SpiralModule =
    {
    name="test102"
    prerequisites=[loop]
    description="Does the unroll work?"
    code=
    """
// TODO
inl f x = x ()
inl dyn = dyn >> ignore
inl x _ = 
    dyn "1" 
    inl _ ->
        dyn "2"
        inl _ ->
            dyn "3"
            inl rec loop _ = dyn "..."; loop
            loop
Loops.unroll f x
    """
    }

let test103: SpiralModule =
    {
    name="test103"
    prerequisites=[loop]
    description="Does the foru work?"
    code=
    """
// TODO
inl f x = x ()
inl dyn = dyn >> ignore
inl x _ = 
    dyn "1" 
    inl _ ->
        dyn "2"
        inl _ ->
            dyn "3"
            inl rec loop _ = dyn "..."; loop
            loop
Loops.foru {from=0; near_to=30; state = x; body = inl {state i} -> state ()}
    """
    }

let loop1: SpiralModule =
    {
    name="loop1"
    prerequisites=[loops; console]
    description="Does the Loop module work?"
    code=
    """
open Console
open Loops
//If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23.
//Find the sum of all the multiples of 3 or 5 below 1000.

for {from=dyn 999; down_to=dyn 3; by=dyn -1; state=dyn 0; body = inl {state i} ->
    if i % 3 = 0 || i % 5 = 0 then state+i
    else state
    }
|> writeline
    """
    }

let loop2: SpiralModule =
    {
    name="loop2"
    prerequisites=[loops; console]
    description="Does the Loop module work?"
    code=
    """
open Console
open Loops

for {from=dyn 3; to=dyn 999; state=dyn 0; body = inl {state i} ->
    if i % 3 = 0 || i % 5 = 0 then state+i
    else state
    }
|> writeline
    """
    }

let loop3: SpiralModule =
    {
    name="loop3"
    prerequisites=[loops; console]
    description="Does the Loop module work?"
    code=
    """
open Console
open Loops

for {static_from=6; down_to=3; by= -1; state=0; body = inl {state i} ->
    if i % 3 = 0 || i % 5 = 0 then state+i
    else state
    }
|> writeline
    """
    }

let loop5: SpiralModule =
    {
    name="loop5"
    prerequisites=[loops]
    description="Does the Loop module work?"
    code=
    """
open Loops

for {static_from=2; to=2; body = inl {i} -> ()}
    """
    }

let loop6: SpiralModule =
    {
    name="loop6"
    prerequisites=[loops; console]
    description="Do state changing nested loops work?"
    code=
    """
open Loops
open Console
inl compare_pos (a_row,a_col) (b_row,b_col) = a_row = b_row && a_col = b_col
inl ret = {
    some = inl state -> printfn "Success." ()
    none = inl state -> failwith () "Failure."
    }
inl princess_pos = dyn (0,0)
inl mario_pos = dyn (1,1)
inl n = 5
for' {from=dyn 0; near_to=n; state={}; 
    body=inl {next=row i=r state} ->
        for' {from=dyn 0; near_to=n; state;
            body=inl {next=col i=c state} ->
                printfn "I am at ({0},{1})" (r, c)
                inl ret state = 
                    match state with
                    | {mario princess} -> ret .some state
                    | _ -> col state
                if compare_pos (r,c) mario_pos then ret {state with mario=mario_pos}
                elif compare_pos (r,c) princess_pos then ret {state with princess=princess_pos}
                else ret state
            finally=row
            }
    finally=ret .none
    }
    """
    }

let loop7: SpiralModule =
    {
    name="loop7"
    prerequisites=[console]
    description="Do state changing nested loops work?"
    code=
    """
open Console
inl compare_pos (a_row,a_col) (b_row,b_col) = a_row = b_row && a_col = b_col
inl ret = {
    some = inl state -> printfn "Success." ()
    none = inl state -> failwith () "Failure."
    }
inl princess_pos = dyn (0,0)
inl mario_pos = dyn (1,1)
inl n = dyn 5
met rec row {from=r near_to state} as d =
    met rec col {from=c near_to state} as d =
        if c < near_to then
            printfn "I am at ({0},{1})" (r, c)
            inl ret = function
                | {mario princess} as state -> ret .some state
                | state -> col {d with state from=c+1}
            if compare_pos (r,c) mario_pos then 
                printfn "I've found Mario." ()
                ret {state with mario=mario_pos}
            elif compare_pos (r,c) princess_pos then 
                printfn "I've found Princess." ()
                ret {state with princess=princess_pos}
            else ret state
        else 
            row {d with from=r+1}
        : ()
    if r < near_to then col {from=dyn 0; near_to state}
    else ret .none () 
    : ()
row {from=dyn 0; near_to=dyn n; state={}}
    """
    }

let loop8: SpiralModule =
    {
    name="loop8"
    prerequisites=[loops; console]
    description="Do state changing nested loops work?"
    code=
    """
open Console

met rec for {from=(!dyn from) near_to state body finally} =
    if from < near_to then 
        inl next state = for {from=from+1; near_to state body finally} 
        body {next state i=from}
    else finally state
    : finally state

inl compare_pos (a_row,a_col) (b_row,b_col) = a_row = b_row && a_col = b_col
inl ret = {
    some = inl state -> printfn "Success." ()
    none = inl state -> failwith () "Failure."
    }
inl princess_pos = dyn (0,0)
inl mario_pos = dyn (1,1)
inl n = dyn 5
for {from=0; near_to=n; state={};
    body = inl {next=row i=r state} ->
        for {from=0; near_to=n; state;
            body = inl {next=col i=c state} ->
                printfn "I am at ({0},{1})" (r, c)
                inl ret = function
                    | {mario princess} as state -> ret .some state
                    | state -> col state
                if compare_pos (r,c) mario_pos then 
                    printfn "I've found Mario." ()
                    ret {state with mario=mario_pos}
                elif compare_pos (r,c) princess_pos then 
                    printfn "I've found Princess." ()
                    ret {state with princess=princess_pos}
                else ret state
            finally = row
            }
    finally = ret .none
    }
    """
    }
